name: pcp-packager
description: Build pCP .tcz from src/pkgroot and stage under /repo/<ver>/<arch>/tcz

inputs:
  pkg:
    description: Package name, produces <pkg>.tcz
    required: true
  pcp_ver:
    description: pCP version path fragment (e.g. 16.x)
    required: false
    default: "16.x"
  arch:
    description: Architecture path fragment (e.g. armhf)
    required: false
    default: "armhf"
  description:
    description: Description for .tcz.info
    required: false
    default: "pCP extension"
  author:
    description: Author for .tcz.info
    required: false
    default: "urknall"
  add_deps:
    description: Write a .dep file (true/false)
    required: false
    default: "false"
  deps_list:
    description: Newline-separated .dep contents (with .tcz suffix)
    required: false
    default: ""
  pages_repo:
    description: Optional GitHub Pages repo to pre-seed (e.g. urknall/pcp-repo)
    required: false
    default: ""
  pages_branch:
    description: Branch to seed from (default gh-pages)
    required: false
    default: "gh-pages"
  pages_token:
    description: Token provided by the caller workflow (e.g. secrets.GH_PAGES_TOKEN)
    required: false
    default: ""

runs:
  using: "composite"
  steps:
    - name: Install packaging tools
      shell: bash
      run: |
        set -e
        sudo apt-get update
        sudo apt-get install -y squashfs-tools rsync git

    - name: Build .tcz and stage into repo tree
      shell: bash
      env:
        PKG:          ${{ inputs.pkg }}
        PCP_VER:      ${{ inputs.pcp_ver }}
        ARCH:         ${{ inputs.arch }}
        DESC:         ${{ inputs.description }}
        AUTHOR:       ${{ inputs.author }}
        ADD_DEPS:     ${{ inputs.add_deps }}
        DEPS_LIST:    ${{ inputs.deps_list }}
        PAGES_REPO:   ${{ inputs.pages_repo }}
        PAGES_BRANCH: ${{ inputs.pages_branch }}
        PAGES_TOKEN:  ${{ inputs.pages_token }}
      run: |
        set -Eeuo pipefail
        set -o errtrace
        trap 'ec=$?; echo "[ERROR] failed at line ${LINENO} (exit ${ec})"; exit ${ec}' ERR

        ROOT="$PWD"
        SRC_DIR="$ROOT/src/pkgroot"
        BUILD="$ROOT/build"
        STAGE="$BUILD/pkgroot"
        OUT="$BUILD/out"
        TCZDIR="$OUT/tcz"
        PUBROOT="$OUT/public"
        PUBDIR="$PUBROOT/repo/${PCP_VER}/${ARCH}/tcz"

        # Version ONLY inside .info (filenames stay unversioned)
        RAW="${GITHUB_REF_NAME:-}"
        if echo "${RAW}" | grep -qE '^v'; then
          VERSION="${RAW#v}"
        else
          VERSION="$(date +%Y.%m.%d)"
        fi

        # Clean build dirs (we will seed PUBROOT with existing site)
        rm -rf "$BUILD"
        mkdir -p "$TCZDIR" "$PUBROOT" "$PUBDIR"

        # ---- Seed existing gh-pages into PUBROOT (so indexes list ALL packages) ----
        if [ -n "${PAGES_REPO}" ]; then
          echo "[INFO] Seeding from ${PAGES_REPO}@${PAGES_BRANCH}"
          GIT_URL="https://github.com/${PAGES_REPO}.git"
          if [ -n "${PAGES_TOKEN}" ]; then
            GIT_URL="https://${GITHUB_ACTOR}:${PAGES_TOKEN}@github.com/${PAGES_REPO}.git"
          fi
          if git clone --depth 1 --branch "${PAGES_BRANCH}" "${GIT_URL}" "${PUBROOT}.tmp" >/dev/null 2>&1; then
            rsync -a --delete --exclude='.git' "${PUBROOT}.tmp"/ "${PUBROOT}"/
            rm -rf "${PUBROOT}.tmp"
            echo "[INFO] Seeded existing site into ${PUBROOT}"
          else
            echo "[WARN] Could not clone ${PAGES_REPO}@${PAGES_BRANCH}; starting with empty site."
          fi
        fi

        # ---- Build only if src/pkgroot exists; otherwise skip build gracefully ----
        if [ -d "$SRC_DIR" ]; then
          echo "[INFO] Building from $SRC_DIR"
          echo "[INFO] Source tree:"; ls -la "$SRC_DIR" || true

          mkdir -p "$STAGE"
          cp -a "$SRC_DIR/." "$STAGE/"

          echo "[INFO] Staged tree:"; ls -la "$STAGE" || true
          [ -d "$STAGE/usr/local" ] && ls -la "$STAGE/usr/local" || true
          [ -d "$STAGE/usr/local/tce.installed" ] && ls -la "$STAGE/usr/local/tce.installed" || true

          # Ensure tce.installed scripts are executable (no glob pitfalls)
          if [ -d "$STAGE/usr/local/tce.installed" ]; then
            for f in "$STAGE"/usr/local/tce.installed/*; do
              [ -f "$f" ] && chmod 755 "$f" || true
            done
          fi

          # Build .tcz
          TCZ="$TCZDIR/${PKG}.tcz"
          echo "[INFO] Running mksquashfs -> $TCZ"
          mksquashfs "$STAGE" "$TCZ" -all-root -noappend -no-xattrs >/dev/null

          echo "[INFO] Built:"; ls -la "$TCZDIR"

          # Work inside tcz dir without pushd/popd
          (
            cd "$TCZDIR"

            # Optional .dep
            if [ "${ADD_DEPS}" = "true" ] && [ -n "${DEPS_LIST}" ]; then
              printf '%s\n' "${DEPS_LIST}" | sed '/^$/d' > "${PKG}.tcz.dep"
            fi

            # Sidecars (with robust unsquashfs fallback)
            md5sum "${PKG}.tcz" > "${PKG}.tcz.md5.txt"

            if unsquashfs -ll "${PKG}.tcz" > ll.txt 2>ll.err; then
              awk 'NR>2{p=$NF; sub(/^squashfs-root\//,"",p); print p}' ll.txt > "${PKG}.tcz.list"
            else
              echo "[WARN] unsquashfs -ll failed; falling back to file-only listing"
              echo "${PKG}.tcz" > "${PKG}.tcz.list"
              echo "---- unsquashfs stderr ----"; sed -n '1,120p' ll.err || true
            fi
            rm -f ll.txt ll.err

            SIZE=$(du -h "${PKG}.tcz" | awk '{print $1}')
            {
              printf 'Title:          %s\n' "${PKG}"
              printf 'Description:    %s\n' "${DESC}"
              printf 'Version:        %s\n' "${VERSION}"
              printf 'Author:         %s\n' "${AUTHOR}"
              printf 'Copying-policy: MIT\n'
              printf 'Size:           %s\n' "${SIZE}"
              printf 'Comments:       Built from src/pkgroot; repo path /repo/%s/%s/tcz/\n' "${PCP_VER}" "${ARCH}"
            } > "${PKG}.tcz.info"
          )

          # Stage into seeded tree
          install -d "${PUBDIR}"
          cp -a ${PKG}.tcz* "${PUBDIR}/"

          # Per-folder index for /repo/<ver>/<arch>/tcz/
          {
            echo '<!doctype html><meta charset="utf-8"><title>pCP repo</title>'
            echo '<h1>pCP repo /repo/'"${PCP_VER}"'/'"${ARCH}"'/tcz/</h1><ul>'
            for f in "${PUBDIR}"/*; do
              bn=$(basename "$f")
              printf '<li><a href="%s">%s</a></li>\n' "$bn" "$bn"
            done
            echo '</ul>'
          } > "${PUBDIR}/index.html"
        else
          echo "[WARN] No source at $SRC_DIR â€” skipping build; regenerating directory indexes only."
        fi

        # ---- Directory indexes for browsing the tree -------------------------------
        make_dir_index() {
          local d="$1"; local title="$2"
          mkdir -p "$d"
          {
            echo '<!doctype html><meta charset="utf-8"><title>'"$title"'</title>'
            echo '<h1>'"$title"'</h1><ul>'
            if [ -d "$d" ]; then
              (cd "$d" && ls -1A) | while read name; do
                [ -d "$d/$name" ] && printf '<li><a href="%s/">%s/</a></li>\n' "$name" "$name"
              done
              (cd "$d" && ls -1A) | while read name; do
                [ -f "$d/$name" ] && printf '<li><a href="%s">%s</a></li>\n' "$name" "$name"
              done
            fi
            echo '</ul>'
          } > "$d/index.html"
        }

        # repo root: lists versions (e.g. 16.x/)
        make_dir_index "$PUBROOT/repo" "pCP repo: /repo/"

        # version level: lists arches (e.g. armhf/, aarch64/)
        make_dir_index "$PUBROOT/repo/${PCP_VER}" "pCP repo: /repo/${PCP_VER}/"

        # arch level: lists subfolders (e.g. tcz/)
        make_dir_index "$PUBROOT/repo/${PCP_VER}/${ARCH}" "pCP repo: /repo/${PCP_VER}/${ARCH}/"

        # ---- Site root index (overview of the whole repo tree) ---------------------
        ROOTIDX="$PUBROOT/index.html"
        mkdir -p "$(dirname "$ROOTIDX")"
        {
          echo '<!doctype html><meta charset="utf-8"><title>pCP repo root</title>'
          echo '<h1>pCP repo root</h1><ul>'
          if [ -d "$PUBROOT/repo" ]; then
            (cd "$PUBROOT" && find repo -type d | sort) | while read d; do
              printf '<li><a href="%s/">%s/</a></li>\n' "$d" "$d"
            done
          else
            echo '<li><em>No repo/ directory yet</em></li>'
          fi
          echo '</ul>'
        } > "$ROOTIDX"
