name: pcp-packager
description: Build pCP .tcz from src/pkgroot and stage under /repo/<ver>/<arch>/tcz

inputs:
  pkg:
    description: Package name, produces <pkg>.tcz
    required: true
  pcp_ver:
    description: pCP version path fragment (e.g. 16.x)
    required: false
    default: "16.x"
  arch:
    description: Architecture path fragment (e.g. armhf)
    required: false
    default: "armhf"
  description:
    description: Description for .tcz.info
    required: false
    default: "pCP extension"
  author:
    description: Author for .tcz.info
    required: false
    default: "urknall"
  add_deps:
    description: Write a .dep file (true/false)
    required: false
    default: "false"
  deps_list:
    description: Newline-separated .dep contents (with .tcz suffix)
    required: false
    default: ""
  pages_repo:
    description: Optional GitHub Pages repo to pre-seed (e.g. urknall/pcp-repo)
    required: false
    default: ""
  pages_branch:
    description: Branch to seed from (default gh-pages)
    required: false
    default: "gh-pages"
  pages_token:
    description: Token provided by the caller workflow (e.g. secrets.GH_PAGES_TOKEN)
    required: false
    default: ""

runs:
  using: "composite"
  steps:
    - name: Install packaging tools
      shell: bash
      run: |
        set -e
        sudo apt-get update
        sudo apt-get install -y squashfs-tools rsync git

    - name: Build .tcz and stage into repo tree
      shell: bash
      env:
        PKG:          ${{ inputs.pkg }}
        PCP_VER:      ${{ inputs.pcp_ver }}
        ARCH:         ${{ inputs.arch }}
        DESC:         ${{ inputs.description }}
        AUTHOR:       ${{ inputs.author }}
        ADD_DEPS:     ${{ inputs.add_deps }}
        DEPS_LIST:    ${{ inputs.deps_list }}
        PAGES_REPO:   ${{ inputs.pages_repo }}
        PAGES_BRANCH: ${{ inputs.pages_branch }}
        PAGES_TOKEN:  ${{ inputs.pages_token }}
      run: |
        set -Eeuo pipefail
        set -o errtrace
        trap 'ec=$?; echo "[ERROR] failed at line ${LINENO} (exit ${ec})"; exit ${ec}' ERR

        ROOT="$PWD"
        SRC_DIR="$ROOT/src/pkgroot"
        BUILD="$ROOT/build"
        STAGE="$BUILD/pkgroot"
        OUT="$BUILD/out"
        TCZDIR="$OUT/tcz"
        PUBROOT="$OUT/public"
        PUBDIR="$PUBROOT/repo/${PCP_VER}/${ARCH}/tcz"

        # Version ONLY inside .info (filenames stay unversioned)
        RAW="${GITHUB_REF_NAME:-}"
        if echo "${RAW}" | grep -qE '^v'; then
          VERSION="${RAW#v}"
        else
          VERSION="$(date +%Y.%m.%d)"
        fi

        echo "[STEP] clean build dirs"
        rm -rf "$BUILD"
        mkdir -p "$TCZDIR" "$PUBROOT" "$PUBDIR"

        # ---- Seed existing gh-pages into PUBROOT ----
        if [ -n "${PAGES_REPO}" ]; then
          echo "[STEP] seed gh-pages from ${PAGES_REPO}@${PAGES_BRANCH}"
          GIT_URL="https://github.com/${PAGES_REPO}.git"
          if [ -n "${PAGES_TOKEN}" ]; then
            GIT_URL="https://${GITHUB_ACTOR}:${PAGES_TOKEN}@github.com/${PAGES_REPO}.git"
          fi
          if git clone --depth 1 --branch "${PAGES_BRANCH}" "${GIT_URL}" "${PUBROOT}.tmp" >/dev/null 2>&1; then
            rsync -a --delete --exclude='.git' "${PUBROOT}.tmp"/ "${PUBROOT}"/
            rm -rf "${PUBROOT}.tmp"
            echo "[INFO] seeded existing site into ${PUBROOT}"
          else
            echo "[WARN] could not clone ${PAGES_REPO}@${PAGES_BRANCH}; starting with empty site."
          fi
        fi

        # ---- Build only if src/pkgroot exists; otherwise skip build gracefully ----
        if [ -d "$SRC_DIR" ]; then
          echo "[STEP] build from $SRC_DIR"
          ls -la "$SRC_DIR" || true

          mkdir -p "$STAGE"
          cp -a "$SRC_DIR/." "$STAGE/"

          echo "[STEP] staged tree"
          ls -la "$STAGE" || true
          [ -d "$STAGE/usr/local" ] && ls -la "$STAGE/usr/local" || true
          [ -d "$STAGE/usr/local/tce.installed" ] && ls -la "$STAGE/usr/local/tce.installed" || true

          # Ensure tce.installed scripts are executable
          if [ -d "$STAGE/usr/local/tce.installed" ]; then
            for f in "$STAGE"/usr/local/tce.installed/*; do
              [ -f "$f" ] && chmod 755 "$f" || true
            done
          fi

          # Build .tcz
          TCZ="$TCZDIR/${PKG}.tcz"
          echo "[STEP] mksquashfs -> $TCZ"
          mksquashfs "$STAGE" "$TCZ" -all-root -noappend -no-xattrs >/dev/null

          echo "[STEP] built artifacts in $TCZDIR"
          ls -la "$TCZDIR" || true

          # Create sidecars inside $TCZDIR (never fail the job)
          echo "[STEP] sidecars start"
          (
            set -e
            cd "$TCZDIR"

            # Optional .dep
            if [ "${ADD_DEPS}" = "true" ] && [ -n "${DEPS_LIST}" ]; then
              printf '%s\n' "${DEPS_LIST}" | sed '/^$/d' > "${PKG}.tcz.dep" || true
            fi

            # MD5
            if ! md5sum "${PKG}.tcz" > "${PKG}.tcz.md5.txt"; then
              echo "[WARN] md5sum failed, writing placeholder"
              echo "md5-unknown  ${PKG}.tcz" > "${PKG}.tcz.md5.txt"
            fi

            # unsquashfs listing (files + leaf dirs only)
            if unsquashfs -ll "${PKG}.tcz" > ll.txt 2>ll.err; then
              awk '
                NR>2 {
                  mode = $1
                  p = $NF
                  sub(/^squashfs-root\//,"",p)
                  if (p == "") next
                  n++; P[n] = p; T[n] = substr(mode,1,1)
                }
                END {
                  for (i=1; i<=n; i++) {
                    if (T[i] != "d") { print P[i]; continue }
                    leaf = 1
                    for (j=1; j<=n; j++) if (i!=j) {
                      if (index(P[j], P[i] "/") == 1) { leaf = 0; break }
                    }
                    if (leaf) print P[i]
                  }
                }
              ' ll.txt | LC_ALL=C sort > "${PKG}.tcz.list" \
              || echo "${PKG}.tcz" > "${PKG}.tcz.list"
            else
              echo "[WARN] unsquashfs -ll failed; falling back to file-only listing"
              echo "${PKG}.tcz" > "${PKG}.tcz.list"
              echo "---- unsquashfs stderr ----"; sed -n '1,120p' ll.err || true
            fi
            rm -f ll.txt ll.err || true

            SIZE=$(du -h "${PKG}.tcz" | awk '{print $1}')
            {
              printf 'Title:          %s\n' "${PKG}"
              printf 'Description:    %s\n' "${DESC}"
              printf 'Version:        %s\n' "${VERSION}"
              printf 'Author:         %s\n' "${AUTHOR}"
              printf 'Copying-policy: MIT\n'
              printf 'Size:           %s\n' "${SIZE}"
              printf 'Comments:       Built from src/pkgroot; repo path /repo/%s/%s/tcz/\n' "${PCP_VER}" "${ARCH}"
            } > "${PKG}.tcz.info"
          )
          echo "[STEP] sidecars done"

          # Stage into seeded tree
          echo "[STEP] stage into ${PUBDIR}"
          install -d "${PUBDIR}"
          for x in "${PKG}.tcz" "${PKG}.tcz.md5.txt" "${PKG}.tcz.list" "${PKG}.tcz.info"; do
            if [ -f "$TCZDIR/$x" ]; then
              cp -a "$TCZDIR/$x" "${PUBDIR}/"
            else
              echo "[WARN] missing $TCZDIR/$x (continuing)"
            fi
          done
          if [ -f "$TCZDIR/${PKG}.tcz.dep" ]; then
            cp -a "$TCZDIR/${PKG}.tcz.dep" "${PUBDIR}/"
          fi

          # Per-folder index for /repo/<ver>/<arch>/tcz/
          echo "[STEP] write index for ${PUBDIR}"
          {
            echo '<!doctype html><meta charset="utf-8"><title>pCP repo</title>'
            echo '<h1>pCP repo /repo/'"${PCP_VER}"'/'"${ARCH}"'/tcz/</h1><ul>'
            (
              shopt -s nullglob dotglob
              for e in "${PUBDIR}/"*; do
                bn=$(basename "$e")
                printf '<li><a href="%s">%s</a></li>\n' "$bn" "$bn"
              done
            )
            echo '</ul>'
          } > "${PUBDIR}/index.html"
        else
          echo "[WARN] No source at $SRC_DIR â€” skipping build; regenerating directory indexes only."
        fi

        # ---- Directory indexes for browsing the tree (pure Bash, no pipes) ----
        make_dir_index() {
          local d="$1"; local title="$2"
          mkdir -p "$d"
          {
            echo '<!doctype html><meta charset="utf-8"><title>'"$title"'</title>'
            echo '<h1>'"$title"'</h1><ul>'
            (
              shopt -s nullglob dotglob
              # subdirectories
              for e in "$d"/*/; do
                [ -d "$e" ] || continue
                bn=$(basename "$e")
                printf '<li><a href="%s/">%s/</a></li>\n' "$bn" "$bn"
              done
              # files
              for e in "$d"/*; do
                [ -f "$e" ] || continue
                bn=$(basename "$e")
                printf '<li><a href="%s">%s</a></li>\n' "$bn" "$bn"
              done
            )
            echo '</ul>'
          } > "$d/index.html"
        }

        echo "[STEP] write repo indexes"
        make_dir_index "$PUBROOT/repo" "pCP repo: /repo/"
        make_dir_index "$PUBROOT/repo/${PCP_VER}" "pCP repo: /repo/${PCP_VER}/"
        make_dir_index "$PUBROOT/repo/${PCP_VER}/${ARCH}" "pCP repo: /repo/${PCP_VER}/${ARCH}/"

        # ---- Site root index (overview) using globbing (no find/pipe) ----
        echo "[STEP] write site root index"
        ROOTIDX="$PUBROOT/index.html"
        mkdir -p "$(dirname "$ROOTIDX")"
        {
          echo '<!doctype html><meta charset="utf-8"><title>pCP repo root</title>'
          echo '<h1>pCP repo root</h1><ul>'
          if [ -d "$PUBROOT/repo" ]; then
            (
              shopt -s nullglob dotglob globstar
              for dir in "$PUBROOT"/repo/**/; do
                [ -d "$dir" ] || continue
                rel=${dir#"$PUBROOT"/}
                printf '<li><a href="%s">%s</a></li>\n' "$rel" "$rel"
              done
            )
          else
            echo '<li><em>No repo/ directory yet</em></li>'
          fi
          echo '</ul>'
        } > "$ROOTIDX"

        echo "[STEP] done"
